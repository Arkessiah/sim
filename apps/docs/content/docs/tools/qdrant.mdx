---
title: Qdrant
description: Use Qdrant vector database
---

import { BlockInfoCard } from "@/components/ui/block-info-card"

<BlockInfoCard 
  type="qdrant"
  color="#1A223F"
  icon={true}
  iconSvg={`<svg className="block-icon"  fill='none' viewBox='0 0 49 56' xmlns='http://www.w3.org/2000/svg'>
      <g clipPath='url(#b)'>
        <path
          d='m38.489 51.477-1.1167-30.787-2.0223-8.1167 13.498 1.429v37.242l-8.2456 4.7589-2.1138-4.5259z'
          clipRule='evenodd'
          fill='#24386C'
          fillRule='evenodd'
        />
        <path
          d='m48.847 14-8.2457 4.7622-17.016-3.7326-19.917 8.1094-3.3183-9.139 12.122-7 12.126-7 12.123 7 12.126 7z'
          clipRule='evenodd'
          fill='#7589BE'
          fillRule='evenodd'
        />
        <path
          d='m0.34961 13.999 8.2457 4.7622 4.7798 14.215 16.139 12.913-4.9158 10.109-12.126-7.0004-12.123-7v-28z'
          clipRule='evenodd'
          fill='#B2BFE8'
          fillRule='evenodd'
        />
        <path
          d='m30.066 38.421-5.4666 8.059v9.5207l7.757-4.4756 3.9968-5.9681'
          clipRule='evenodd'
          fill='#24386C'
          fillRule='evenodd'
        />
        <path
          d='m24.602 36.962-7.7603-13.436 1.6715-4.4531 6.3544-3.0809 7.488 7.5343-7.7536 13.436z'
          clipRule='evenodd'
          fill='#7589BE'
          fillRule='evenodd'
        />
        <path
          d='m16.843 23.525 7.7569 4.4756v8.9585l-7.1741 0.3087-4.3397-5.5412 3.7569-8.2016z'
          clipRule='evenodd'
          fill='#B2BFE8'
          fillRule='evenodd'
        />
        <path
          d='m24.6 28 7.757-4.4752 5.2792 8.7903-6.3886 5.2784-6.6476-0.6346v-8.9589z'
          clipRule='evenodd'
          fill='#24386C'
          fillRule='evenodd'
        />
        <path
          d='m32.355 51.524 8.2457 4.476v-37.238l-8.0032-4.6189-7.9995-4.6189-8.0031 4.6189-7.9995 4.6189v18.479l7.9995 4.6189 8.0031 4.6193 7.757-4.4797v9.5244zm0-19.045-7.757 4.4793-7.7569-4.4793v-8.9549l7.7569-4.4792 7.757 4.4792v8.9549z'
          clipRule='evenodd'
          fill='#DC244C'
          fillRule='evenodd'
        />
        <path d='m24.603 46.483v-9.5222l-7.7166-4.4411v9.5064l7.7166 4.4569z' fill='url(#a)' />
      </g>
      <defs>
        <linearGradient
          id='a'
          x1='23.18'
          x2='15.491'
          y1='38.781'
          y2='38.781'
          gradientUnits='userSpaceOnUse'
        >
          <stop stopColor='#FF3364' offset='0' />
          <stop stopColor='#C91540' stopOpacity='0' offset='1' />
        </linearGradient>
        <clipPath id='b'>
          <rect transform='translate(.34961)'   fill='#fff' />
        </clipPath>
      </defs>
    </svg>`}
/>

{/* MANUAL-CONTENT-START:intro */}
[Qdrant](https://qdrant.tech) is an open-source vector database designed for efficient storage, management, and retrieval of high-dimensional vector embeddings. Qdrant enables fast and scalable semantic search, making it ideal for AI applications that require similarity search, recommendation systems, and contextual information retrieval.

With Qdrant, you can:

- **Store vector embeddings**: Efficiently manage and persist high-dimensional vectors at scale
- **Perform semantic similarity search**: Find the most similar vectors to a query vector in real time
- **Filter and organize data**: Use advanced filtering to narrow down search results based on metadata or payload
- **Fetch specific points**: Retrieve vectors and their associated payloads by ID
- **Scale seamlessly**: Handle large collections and high-throughput workloads

In Sim, the Qdrant integration enables your agents to interact with Qdrant programmatically as part of their workflows. Supported operations include:

- **Upsert**: Insert or update points (vectors and payloads) in a Qdrant collection
- **Search**: Perform similarity search to find vectors most similar to a given query vector, with optional filtering and result customization
- **Fetch**: Retrieve specific points from a collection by their IDs, with options to include payloads and vectors

This integration allows your agents to leverage powerful vector search and management capabilities, enabling advanced automation scenarios such as semantic search, recommendation, and contextual retrieval. By connecting Sim with Qdrant, you can build agents that understand context, retrieve relevant information from large datasets, and deliver more intelligent and personalized responses—all without managing complex infrastructure.
{/* MANUAL-CONTENT-END */}


## Operations

### `qdrant_upsert_points`

Insert or update points in a Qdrant collection

#### Input

| Parameter | Type | Required | Description |
| --------- | ---- | -------- | ----------- |
| `url` | string | Yes | Qdrant base URL |
| `apiKey` | string | No | Qdrant API key \(optional\) |
| `collection` | string | Yes | Collection name |
| `points` | array | Yes | Array of points to upsert |

#### Output

| Parameter | Type | Description |
| --------- | ---- | ----------- |
| `status` | string | Status of the upsert operation |
| `data` | object | Result data from the upsert operation |

### `qdrant_search_vector`

Search for similar vectors in a Qdrant collection

#### Input

| Parameter | Type | Required | Description |
| --------- | ---- | -------- | ----------- |
| `url` | string | Yes | Qdrant base URL |
| `apiKey` | string | No | Qdrant API key \(optional\) |
| `collection` | string | Yes | Collection name |
| `vector` | array | Yes | Vector to search for |
| `limit` | number | No | Number of results to return |
| `filter` | object | No | Filter to apply to the search |
| `with_payload` | boolean | No | Include payload in response |
| `with_vector` | boolean | No | Include vector in response |

#### Output

| Parameter | Type | Description |
| --------- | ---- | ----------- |
| `data` | array | Vector search results with ID, score, payload, and optional vector data |
| `status` | string | Status of the search operation |

### `qdrant_fetch_points`

Fetch points by ID from a Qdrant collection

#### Input

| Parameter | Type | Required | Description |
| --------- | ---- | -------- | ----------- |
| `url` | string | Yes | Qdrant base URL |
| `apiKey` | string | No | Qdrant API key \(optional\) |
| `collection` | string | Yes | Collection name |
| `ids` | array | Yes | Array of point IDs to fetch |
| `with_payload` | boolean | No | Include payload in response |
| `with_vector` | boolean | No | Include vector in response |

#### Output

| Parameter | Type | Description |
| --------- | ---- | ----------- |
| `data` | array | Fetched points with ID, payload, and optional vector data |
| `status` | string | Status of the fetch operation |



## Best Practices

{/* MANUAL-CONTENT-START:bestPractices */}
When integrating the Qdrant block into your Sim.ai workflows, following established best practices ensures efficient vector operations and optimal search performance. The Qdrant block serves as a powerful semantic search engine within your automated workflows, enabling advanced AI applications that require similarity matching, recommendation systems, and intelligent content retrieval.

**Connection Tag Usage and Data Flow**

Proper connection tag implementation is crucial for effective vector database operations. The `<embeddings1.vectors>` connection tag from OpenAI or other embedding blocks provides the vector data required for the `<qdrant1.vector>` input field. When upserting points, structure your data flow using `<function1.formattedPoints>` to properly format arrays of points with IDs, vectors, and payload data before connecting to `<qdrant1.points>`.

For search operations, connect AI-generated vectors directly: `<openai1.embedding>` → `<qdrant1.vector>` creates seamless semantic search capabilities. The `<qdrant1.matches>` output provides structured search results that can be consumed by downstream blocks. Use `<qdrant1.data>` for detailed operation responses and `<qdrant1.status>` for error handling and flow control.

When chaining multiple Qdrant operations, leverage the `<qdrant1.upsertedCount>` output to validate successful insertions before proceeding with search operations. This ensures data consistency across your vector pipeline.

**Workflow Architecture Patterns**

Successful Qdrant workflows follow distinct architectural patterns based on use case. The **Content Ingestion** pattern implements **API/Webhook → Text Processing → OpenAI Embeddings → Qdrant Upsert**, ideal for building knowledge bases from incoming content. This pattern ensures new information is immediately vectorized and stored for future retrieval.

The **Semantic Search** pattern follows **User Query → OpenAI Embeddings → Qdrant Search → Response Generation**, enabling intelligent question-answering systems. For recommendation engines, implement **User Behavior → Feature Extraction → Qdrant Search → Content Filtering** workflows that provide personalized content suggestions.

**RAG (Retrieval Augmented Generation)** implementations benefit from **Query → Qdrant Search → Context Assembly → LLM Generation** patterns, where vector search results provide relevant context for AI response generation. Consider implementing **Batch Processing** patterns for large-scale data operations: **Data Source → Batch Function → Multiple Qdrant Upserts** to efficiently handle high-volume vector insertions.

**Vector Data Formatting Excellence**

Vector data requires precise formatting to ensure successful operations. Structure point arrays with consistent schemas: each point must include `id`, `vector`, and `payload` fields. Use Function blocks to transform raw data into Qdrant-compatible formats before upserting. Ensure vector dimensions match your embedding model consistently - mixing 768-dimensional and 1536-dimensional vectors within the same collection will cause errors.

Implement payload standardization across your collections. Include metadata fields like `timestamp`, `source`, `category`, and `content_type` to enable sophisticated filtering during searches. Use consistent data types within payload fields to prevent search filter complications.

For search operations, normalize input vectors to unit length when using cosine similarity. Structure filter objects using Qdrant's filter syntax with `must`, `should`, and `must_not` conditions. Implement pagination using the `limit` parameter for large result sets, typically starting with limits between 10-50 for optimal performance.

**Debugging and Monitoring**

Enable comprehensive monitoring using the `<qdrant1.status>` output for all operations. Successful operations return "success" status, while errors provide detailed failure information. Monitor `<qdrant1.upsertedCount>` to track insertion rates and identify potential data pipeline issues.

Implement vector dimension validation before upsert operations. Use Function blocks to verify that all vectors in your point arrays have identical dimensions matching your collection configuration. Log vector search scores from `<qdrant1.matches>` to monitor search quality - consistently low scores may indicate embedding model mismatches or poor data quality.

Track search performance by monitoring response times and result relevance. If searches return consistently irrelevant results, examine your embedding strategy and consider reprocessing source data. Use the `with_payload` and `with_vector` parameters strategically - including unnecessary data increases response times and bandwidth usage.

**Security Considerations**

Implement proper API key management when connecting to Qdrant instances. Use environment variables or secure storage for the `<qdrant1.apiKey>` field rather than hardcoding credentials in workflows. For production deployments, ensure Qdrant URLs use HTTPS connections to encrypt data in transit.

Consider payload data sensitivity when structuring vector points. Avoid storing personally identifiable information (PII) directly in payloads. Instead, use reference IDs that link to secure data stores. Implement collection-level access controls by using different Qdrant collections for different data sensitivity levels.

Validate input data before upsert operations to prevent injection attacks or malformed data corruption. Use Function blocks to sanitize and validate all payload data, especially when processing user-generated content or external API responses.

**Performance Optimization**

Optimize collection configurations based on your use case. For high-throughput applications, configure appropriate indexing parameters and consider using quantization to reduce memory usage. Batch upsert operations when possible - grouping multiple points into single upsert calls reduces API overhead and improves performance.

Implement intelligent caching strategies for frequently accessed vectors. Use the `<qdrant1.data>` output to cache search results in faster storage systems for repeated queries. Consider implementing vector preprocessing pipelines that normalize and optimize embeddings before storage.

For search operations, tune the `limit` parameter based on your downstream processing capabilities. Higher limits provide more comprehensive results but increase processing time and bandwidth usage. Implement smart filtering strategies using the `filter` parameter to reduce search space and improve response times.

Monitor collection size and implement data lifecycle management. Regularly archive or delete outdated vectors to maintain optimal search performance. Use batch fetch operations with `<qdrant1.ids>` for efficient bulk data retrieval rather than individual point requests.

Consider implementing vector compression techniques for storage optimization while maintaining search accuracy. Balance precision requirements with storage costs by selecting appropriate vector quantization settings based on your specific use case requirements.
{/* MANUAL-CONTENT-END */}


## FAQ

{/* MANUAL-CONTENT-START:faq */}
### How do I store vector embeddings in a Qdrant collection from my workflow?

To store vector embeddings in Qdrant, add a **Qdrant block** to your Sim.ai workflow and configure the upsert operation:

#### Required Inputs

| Input | Description | Example |
|-------|-------------|---------|
| `url` | Your Qdrant server base URL | `<start.qdrantUrl>` or `https://your-cluster.qdrant.tech` |
| `collection` | Target collection name | `<start.collectionName>` or static name like `documents` |
| `points` | Array of points with vectors and metadata | `<embeddings1.points>` or structured array |

#### Point Structure
```json
[
  {
    "id": 1,
    "vector": [0.1, 0.2, 0.3, ...],
    "payload": {"text": "Document content", "category": "news"}
  }
]
```

### How do I perform semantic similarity searches with the Qdrant block?

To search for similar vectors in your Qdrant collection:

1. **Set the operation** to `qdrant_search_vector`
2. **Configure search inputs**:

| Input | Description | Example |
|-------|-------------|---------|
| `url` | Qdrant server URL | `<start.qdrantUrl>` |
| `collection` | Collection to search | `<start.collectionName>` |
| `vector` | Query vector for similarity search | `<embeddings1.vector>` |
| `limit` | Maximum results to return | `<start.limit>` or static number like `10` |
| `with_payload` | Include metadata in results | `true` |

### What is the correct way to reference Qdrant block outputs in my workflow?

Every Qdrant block exposes outputs that can be referenced using connection tags:

#### Available Outputs

| Output Tag | Type | Description |
|------------|------|-------------|
| `<qdrant1.data>` | Array/Object | Main result data from the operation |
| `<qdrant1.status>` | String | Operation status (success/error) |
| `<qdrant1.matches>` | Array | Search results with similarity scores |
| `<qdrant1.upsertedCount>` | Number | Number of points successfully upserted |

#### Search Result Structure
When using `<qdrant1.matches>`, each result contains:
- `id`: Point identifier
- `score`: Similarity score (0-1)
- `payload`: Associated metadata
- `vector`: Original vector (if `with_vector` is true)

### How do I connect an Agent block's embeddings to Qdrant for storage?

To store AI-generated embeddings in Qdrant:

1. **Agent generates content** → `<agent1.content>`
2. **Embeddings block creates vectors** → `<embeddings1.vectors>`
3. **Qdrant block stores data**:

#### Example Configuration
```json
{
  "collection": "knowledge_base",
  "points": [
    {
      "id": "<function1.generateId>",
      "vector": "<embeddings1.vector>",
      "payload": {
        "text": "<agent1.content>",
        "timestamp": "<start.timestamp>"
      }
    }
  ]
}
```

### Why is my Qdrant operation failing with authentication errors?

Troubleshoot Qdrant authentication and connection issues:

#### Common Issues and Solutions

| Issue | Description | Solution |
|-------|-------------|----------|
| **Missing API Key** | Cloud Qdrant requires authentication | Add `apiKey` input with `<start.qdrantApiKey>` |
| **Wrong URL Format** | Incorrect server URL | Ensure URL includes protocol: `https://cluster.qdrant.tech` |
| **Collection Not Found** | Target collection doesn't exist | Create collection first or verify name in `<qdrant1.collection>` |
| **Invalid Vector Dimensions** | Vector size mismatch | Ensure `<embeddings1.vector>` matches collection dimensions |
| **Network Timeout** | Connection issues | Check Qdrant server status and network connectivity |

### Can I build a RAG system using Qdrant with other Sim.ai blocks?

Yes! Qdrant integrates perfectly with other blocks for Retrieval-Augmented Generation:

#### RAG Workflow Pattern
```
Webhook → Embeddings → Qdrant Search → Agent → Response
```

##### 1. **Store Knowledge (Setup)**
```
Document → Embeddings → Qdrant Upsert
```
- Process documents with `<embeddings1.vector>`
- Store in Qdrant with `<qdrant1.upsertedCount>` confirmation

##### 2. **Query Knowledge (Runtime)**
```
User Question → Embeddings → Qdrant Search → Context Retrieval
```
- Convert question: `<embeddings2.vector>`
- Search similar: `<qdrant2.matches>`
- Extract context: `<qdrant2.data[0].payload.text>`

##### 3. **Generate Response**
```
Agent Input: "Context: <qdrant2.matches> Question: <start.question>"
```

### How do I fetch specific points by ID from my Qdrant collection?

To retrieve specific points using their IDs:

1. **Set operation** to `qdrant_fetch_points`
2. **Configure fetch inputs**:

| Input | Description | Example |
|-------|-------------|---------|
| `collection` | Collection name | `<start.collectionName>` |
| `ids` | Array of point IDs to fetch | `<start.pointIds>` or `[1, 2, 3]` |
| `with_payload` | Include metadata | `true` |
| `with_vector` | Include vector data | `false` (unless needed) |

#### Use Case Example
```
Condition → Qdrant Fetch (if specific IDs needed)
         → Qdrant Search (if similarity search needed)
```

Connect `<qdrant1.data>` to downstream blocks for further processing of the retrieved points.
{/* MANUAL-CONTENT-END */}
